<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2022强网杯线下赛游记&amp;区块链WP</title>
    <url>/2022/08/28/qwbCTF/</url>
    <content><![CDATA[<h1 id="2022强网杯线下赛游记-amp-区块链WP"><a href="#2022强网杯线下赛游记-amp-区块链WP" class="headerlink" title="2022强网杯线下赛游记&amp;区块链WP"></a>2022强网杯线下赛游记&amp;区块链WP</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>这次强网杯初赛只拿了$40^{st}$，本以为和决赛无缘了，后来竟误打误撞进了决赛。恰好决赛时间和信息安全作品赛撞在一起，于是我便带着三位大一的同学一起参赛，也算是出乎意料的拿到了$15^{th}$。用一位学长的话来讲：“年轻人思维快，KOH打得好。”</p>
<p>第十五名擦边进了二等奖，和雷泽，NeSE，bk，syclover，几个顶尖战队一个奖项，可谓是“夕死可矣“（笑）。</p>
<h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><p>前一天晚上打了几局糖豆人，吃了几局鸡，早上起来略微有些晚。酒店的早餐还算不错（可惜炒饭太难吃了）。由于初赛排名过于靠后，分配了侧面最后一排的坐席。比赛一开始便放了两个KOH和所有的RW题。其中一个KOH（HashRSA）要求构造一段shellcode，执行后将两个数字放在数据区，然后计算shellcode的md5哈希并减去上述两个数字相乘，得到的数字越小得分越高。</p>
<p>看到这个题，我和另一位密码手就兴奋起来了（尤其是名字上还带RSA，虽然和RSA也没什么关系）。他先写了个pow，我写了个爆破脚本。由于提交并不检查是否为有效的shellcode，写好pow随意提交了我们便拿到了第一轮的第一名（+8分）（OI爷写pow就是快！）。与此同时，我的random.randint()函数不负众望的跑出了一个很不错的结果，然后直接提交便得到了不少轮次的分数。之后似乎路就走偏了，我用一台高性能服务器不断地碰撞哈希，不断给出了更优解，但是，显而易见的是，这并不是正解，不过看到AAA，0x300R等战队也在不断枚举，毕竟是KOH嘛，就挂了一个爆破脚本让他自己跑，跑到之后自动提交，居然凭借POW写的快的优势率先拿到了100分，收获了本次线下赛唯一一面flag。</p>
<p>由此同时，我们的misc手差不多也找到了RW题totolink的CVE尝试复现，后面又出了几个KOH，其中一个和DEF CON某年的题目差不多，要求给一段shellcode能够读取&#x2F;flag文件，且在越多的架构上能执行、shellcode长度越短，得分越高。pwn手对着这个题调了一下午；晚上临结束时又放了一个虚拟机逆向题，要求在该虚拟机内输出斐波那契数列的项。能够输出的项数越多分数越高。晚上吃完饭和misc手一起逆了一会我便睡觉了。misc手则写了一份虚拟机使用指南，给OI爷，熬到四五点写了个能输出五十多项的shellcode。</p>
<h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><p>然而，Redbud和0x300R几个战队似乎已经自己写了高精度编译器，能够输出上百项。我们的代码是照着使用说明直接写的汇编，由于push指令数量受到限制，用特判的方法也不太能输出更多项数。OI爷便开始手撸编译器。巧的是上午十点左右放了一波题，其中有一道区块链，这下终于到了我的主场。快速配了一下web3环境就开始撸，到下午两三点差不多赚了两三百分的KOH。<br>RW这边则是misc手扛起了大旗。照着CVE手搓三道totolink，web手则对着CMS刚了一天。比赛临结束时，OI爷把虚拟机冲上了第三。等到RW排队结束，我们已经在开香槟了（bushi）。最终也不负众望拿下二等奖。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>第一次作为队长参加强网杯决赛，成绩也还算不错。可惜的是因为疫情没有办法在郑州逛一逛。只是去吃了烩面，最后一晚老师带着去吃了烤鱼。幸运的是，刚回到学校，郑州就出了几个无症状感染者，还好不用隔离。总之，再接再厉，明年再战吧。</p>
<h2 id="区块链KOH（money）"><a href="#区块链KOH（money）" class="headerlink" title="区块链KOH（money）"></a>区块链KOH（money）</h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>题目给每个战队分配了100eth，同时在测试链上部署了如下的合约。看起来像是一道生拼硬凑的题（甚至其中一部分还是某个其他比赛的原题），每过一关就可以拿到一些钱。合约代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.5.10;</span><br><span class="line"></span><br><span class="line">contract Money &#123;</span><br><span class="line">    mapping (address =&gt; bool) private perm;</span><br><span class="line">    address[32] private users;</span><br><span class="line">    address owner;</span><br><span class="line">    function () external payable &#123;&#125;</span><br><span class="line">    function donate() external payable &#123;&#125;</span><br><span class="line">    constructor() public payable&#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        users = [];//所有比赛选手的账号</span><br><span class="line">        for(uint i = 0; i &lt; users.length; i++)&#123;</span><br><span class="line">            perm[users[i]] = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mapping (address =&gt; bool) private p3f1;</span><br><span class="line">    function easy1() external payable &#123;</span><br><span class="line">        assert(!p3f1[msg.sender]);</span><br><span class="line">        assert(perm[msg.sender]);</span><br><span class="line">        uint dice = uint(keccak256(abi.encode(msg.sender,block.number))) % 6;</span><br><span class="line">        if(dice == 0)&#123;</span><br><span class="line">            msg.sender.transfer(1 ether);</span><br><span class="line">            p3f1[msg.sender] = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mapping (address =&gt; bool) private p3f2;</span><br><span class="line">    mapping (address =&gt; uint) private last_block;</span><br><span class="line">    function easy2() external payable &#123;</span><br><span class="line">        assert(!p3f2[msg.sender]);</span><br><span class="line">        assert(perm[msg.sender]);</span><br><span class="line">        assert(block.number != last_block[msg.sender]);</span><br><span class="line">        uint dice = uint(keccak256(abi.encode(msg.sender,block.number,now))) % 6;</span><br><span class="line">        last_block[msg.sender] = block.number;</span><br><span class="line">        if(dice == 0)&#123;</span><br><span class="line">            msg.sender.transfer(2 ether);</span><br><span class="line">            p3f2[msg.sender] = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">bytearray(keccak_256(data).digest()[:4])</span><br><span class="line">    mapping (address =&gt; uint) gtm;</span><br><span class="line">    function guess_the_number(uint nonce) external payable &#123;</span><br><span class="line">        assert(perm[msg.sender]);</span><br><span class="line">        assert(gtm[msg.sender] &lt;= 20);</span><br><span class="line">        assert(msg.value == 1 ether);</span><br><span class="line">        assert(nonce &lt;= 100);</span><br><span class="line">        uint256 temp = uint256(keccak256(abi.encode(msg.sender)));</span><br><span class="line">        temp = uint256(keccak256(abi.encode(temp, block.number)));</span><br><span class="line">        temp = uint256(keccak256(abi.encode(temp, temp)));</span><br><span class="line">        temp = temp % 100;</span><br><span class="line">        if (nonce == temp) &#123;</span><br><span class="line">            gtm[msg.sender]++;</span><br><span class="line">            msg.sender.transfer(5 ether);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mapping (address =&gt; uint) 0;</span><br><span class="line">    address payable private p1;</span><br><span class="line">    uint256 private dplays;</span><br><span class="line">    function duel1v1() external payable &#123;</span><br><span class="line">        assert(perm[msg.sender]);</span><br><span class="line">        assert(duel[msg.sender] &lt;= 30);</span><br><span class="line">        assert(msg.value == 1 ether);</span><br><span class="line">        assert(p1 != msg.sender);</span><br><span class="line">        duel[msg.sender]++;</span><br><span class="line">        if(dplays == 0)&#123;</span><br><span class="line">            p1 = msg.sender;</span><br><span class="line">            dplays = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            uint winner =  uint256(keccak256(abi.encode(msg.sender,p1))) % 2;</span><br><span class="line">            if(winner == 0)&#123;</span><br><span class="line">                msg.sender.transfer(5 ether);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                p1.transfer(6 ether);</span><br><span class="line">            &#125;</span><br><span class="line">            delete dplays;</span><br><span class="line">            delete p1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    address payable private p1h;</span><br><span class="line">    uint256 dhplays;</span><br><span class="line">    function duel_highroller() external payable &#123;</span><br><span class="line">        assert(perm[msg.sender]);</span><br><span class="line">        assert(duel[msg.sender] &lt;= 30);</span><br><span class="line">        assert(msg.value == 5 ether);</span><br><span class="line">        assert(p1h != msg.sender);</span><br><span class="line">        duel[msg.sender]++;</span><br><span class="line">        if(dhplays == 0)&#123;</span><br><span class="line">            p1h = msg.sender;</span><br><span class="line">            dhplays = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            uint winner =  uint256(keccak256(abi.encode(msg.sender,p1h))) % 2;</span><br><span class="line">            if(winner == 0)&#123;</span><br><span class="line">                msg.sender.transfer(10 ether);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                p1h.transfer(12 ether);</span><br><span class="line">            &#125;</span><br><span class="line">            delete dhplays;</span><br><span class="line">            delete p1h;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mapping (address =&gt; uint256) previous_max;</span><br><span class="line">    function pay_to_mine(uint nonce, uint d) external payable &#123;</span><br><span class="line">        assert(msg.value == 1 ether);</span><br><span class="line">        assert(d &gt;= 26);</span><br><span class="line">        assert(d &gt; previous_max[msg.sender]);</span><br><span class="line">        uint256 hash = uint256(keccak256(abi.encode(nonce,msg.sender)));</span><br><span class="line">        uint mask = 1&lt;&lt;d;</span><br><span class="line">        if (hash % mask == 0) &#123;</span><br><span class="line">            previous_max[msg.sender] = d;</span><br><span class="line">            uint amt = 1&lt;&lt;(d-26);</span><br><span class="line">            msg.sender.transfer(amt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    address payable public richest;</span><br><span class="line">    uint256 public most_sent;</span><br><span class="line">    uint256 public coup_block;</span><br><span class="line">    mapping (address =&gt; uint256) pending_withdrawals;</span><br><span class="line">    function KOTH_coup() public payable returns (bool) &#123;</span><br><span class="line">        if (msg.value &gt; most_sent) &#123;</span><br><span class="line">            if(coup_block == 0)&#123;</span><br><span class="line">                coup_block = block.number;</span><br><span class="line">            &#125;</span><br><span class="line">            richest = msg.sender;</span><br><span class="line">            pending_withdrawals[richest] += msg.value;</span><br><span class="line">            uint amount = block.number - coup_block;</span><br><span class="line">            amount = amount&gt;&gt;3;</span><br><span class="line">            amount = amount + 1;</span><br><span class="line">            richest.transfer(amount * (6 ether));</span><br><span class="line">            coup_block = block.number;</span><br><span class="line">            most_sent = msg.value;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function KOTH_withdraw() public &#123;</span><br><span class="line">        uint256 amt = pending_withdrawals[msg.sender];</span><br><span class="line">        pending_withdrawals[msg.sender] = 0;</span><br><span class="line">        msg.sender.transfer(amt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    uint256 public nonce;</span><br><span class="line">    uint256 lasttime;</span><br><span class="line">    function bet(uint256 value, uint256 _mod) public payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">        address _addr = msg.sender;</span><br><span class="line"></span><br><span class="line">        require(lasttime != block.timestamp);</span><br><span class="line">        require(_mod &gt;= 2 &amp;&amp; _mod &lt; 10);</span><br><span class="line"></span><br><span class="line">        value = value % _mod;</span><br><span class="line"></span><br><span class="line">        uint32 size;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            size := extcodesize(_addr)</span><br><span class="line">        &#125;</span><br><span class="line">        require(size == 0);</span><br><span class="line"></span><br><span class="line">        uint256 rand = uint256(</span><br><span class="line">            keccak256(</span><br><span class="line">                abi.encodePacked(</span><br><span class="line">                    nonce,</span><br><span class="line">                    block.timestamp,</span><br><span class="line">                    block.difficulty,</span><br><span class="line">                    msg.sender</span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line">        ) % _mod;</span><br><span class="line">        nonce += _mod;</span><br><span class="line">        lasttime = block.timestamp;</span><br><span class="line"></span><br><span class="line">        if (value == rand) &#123;</span><br><span class="line">            msg.sender.transfer(3 ether);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    uint256 private plays = 0;</span><br><span class="line">    uint256 private total = 0;</span><br><span class="line">    uint256[101] private counter;</span><br><span class="line">    address payable[101] private identity;</span><br><span class="line">    address payable[5] private already_played;</span><br><span class="line">    </span><br><span class="line">    mapping (address =&gt; uint) mayor;</span><br><span class="line"></span><br><span class="line">    function mayor_voting() external payable &#123;</span><br><span class="line">        if(msg.value  % (1 ether) != 0 || msg.value == 0 || msg.value &gt; (100 ether))&#123;</span><br><span class="line">            revert();</span><br><span class="line">        &#125;</span><br><span class="line">        assert(mayor[msg.sender] &lt;= 30);</span><br><span class="line">        uint256 val = msg.value / (1 ether);</span><br><span class="line"></span><br><span class="line">        for(uint i = 0; i &lt; 5; i++)&#123;</span><br><span class="line">            if(already_played[i] == msg.sender) &#123;</span><br><span class="line">                revert();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mayor[msg.sender]++;</span><br><span class="line">        already_played[plays] = msg.sender;</span><br><span class="line">        plays++;</span><br><span class="line">        counter[val]++;</span><br><span class="line">        identity[val] = msg.sender;</span><br><span class="line">        total += msg.value;</span><br><span class="line"></span><br><span class="line">        if (plays == 5) &#123;</span><br><span class="line">            bool paid = false;</span><br><span class="line">            for (uint i = 0; i &lt; 101; i++) &#123;</span><br><span class="line">                if(counter[i] == 1 &amp;&amp; !paid)&#123;</span><br><span class="line">                    identity[i].transfer(total + (5 ether));</span><br><span class="line">                    paid = true;</span><br><span class="line">                &#125;</span><br><span class="line">                delete counter[i];</span><br><span class="line">                delete identity[i];</span><br><span class="line">            &#125;</span><br><span class="line">            plays = 0;</span><br><span class="line">            total = 0;</span><br><span class="line"></span><br><span class="line">            for (uint i = 0; i &lt; 5; i++)</span><br><span class="line">                delete already_played[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>强网杯</tag>
        <tag>BlockChain</tag>
      </tags>
  </entry>
</search>
